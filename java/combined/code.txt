This is the source code for the Distributed File System implemented by

* Zhou Xinzi
* Hou Yunqing
* Lu Shengliang

, where names are sorted in total length,
and also in reversely sorted in length of surname.

This is a Java project built by Gradle. The Gradle files are come in
first and then the Java source codes.

Note: The name of the file is printed between "==>" and "<==" before
the content of the file.

==> ./client/build.gradle <==
group 'cloud.yogurt'
version '1.0-SNAPSHOT'

apply plugin:'application'

sourceCompatibility = 1.8

mainClassName = "cloud.yogurt.client.cmd.YogurtClient"

repositories {
    mavenCentral()
}

run{
    standardInput = System.in
}

dependencies {
    compile project(":shared")
    testCompile group: 'junit', name: 'junit', version: '4.11'
}
==> ./server/build.gradle <==
group 'cloud.yogurt'
version '1.0-SNAPSHOT'

apply plugin:'application'

sourceCompatibility = 1.8

mainClassName = "cloud.yogurt.server.cmd.YogurtServer"

repositories {
    mavenCentral()
}

run{
    standardInput = System.in
}

dependencies {
    compile project(":shared")
    testCompile group: 'junit', name: 'junit', version: '4.11'
}
==> ./settings.gradle <==
rootProject.name = 'YogurtCloud'

include "shared"
include "server"
include "client"

==> ./shared/build.gradle <==
group 'cloud.yogurt'
version '1.0-SNAPSHOT'

apply plugin: 'java'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    compile 'org.apache.commons:commons-lang3:3.4'
    compile 'commons-io:commons-io:2.4'
    testCompile group: 'junit', name: 'junit', version: '4.11'
}==> ./client/src/main/java/cloud/yogurt/client/cmd/YogurtClient.java <==
package cloud.yogurt.client.cmd;

import cloud.yogurt.client.filecache.FileCache;
import cloud.yogurt.client.remoteserver.RemoteServer;
import cloud.yogurt.client.remoteserver.YogurtServer;
import cloud.yogurt.client.servicecall.*;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.network.PacketException;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Scanner;


/**
 * Entry point to YogurtCloud client application.
 */
public class YogurtClient {
    private static Logger log = Logger.getLogger(YogurtClient.class.getName());

    private static YogurtServer server;

    public static void main(String[] args) throws InterruptedException, UnknownHostException {
        log.info("Starting Yogurt Client");

        Logger.silent = false;

        InetAddress address = SharedConfig.SERVER_ADDRESS;
        int port = SharedConfig.SERVER_PORT;

        if (args.length > 0) {
            String serverHost = args[0];
            address = InetAddress.getByName(serverHost);
            if (args.length > 1) {
                port = Integer.parseInt(args[1]);
            }
        }

        server = new YogurtServer(address, port);

        Logger.printRaw("Welcome to Yogurt Cloud. Server: " + address.toString() + ":" + port);

        Scanner scanner = new Scanner(System.in);
        while (true) {
            while (server.isServerBusy()) {
                Thread.sleep(100);
            }

            System.out.print(">> ");
            String command = scanner.nextLine();
            if (command.length() == 0) continue;

            String[] components = command.split(" ");
            String function = components[0];

            try {
                switch (function) {
                    case "exit": {
                        System.out.println("Bye.");
                        server.stop();
                        System.exit(0);
                    }
                    case "silent": {
                        Logger.silent = true;
                        break;
                    }
                    case "get": {
                        String path = components[1];
                        if (components.length > 2) {
                            int offset = Integer.parseInt(components[2]);
                            int limit = Integer.MAX_VALUE;
                            if (components.length > 3) {
                                limit = Integer.parseInt(components[3]);
                            }
                            server.get(path, offset, limit);
                        } else {
                            server.get(path);
                        }
                        break;
                    }
                    case "insert": {
                        String path = components[1];
                        int offset = Integer.parseInt(components[2]);
                        String fragment = components[3];
                        server.insert(path, offset, fragment);
                        break;
                    }
                    case "monitor": {
                        String path = components[1];
                        int duration = Integer.parseInt(components[2]);
                        server.monitor(path, duration);
                        break;
                    }
                    case "delete": {
                        String path = components[1];
                        int offset = Integer.parseInt(components[2]);
                        int length = Integer.parseInt(components[3]);
                        server.delete(path, offset, length);
                        break;
                    }
                    case "check": {
                        String path = components[1];
                        server.check(path);
                        break;
                    }
                }
            } catch (ArrayIndexOutOfBoundsException | NumberFormatException ignored) {
                Logger.printRaw("Illegal parameters. Please check.");
            }
        }
    }
}

==> ./client/src/main/java/cloud/yogurt/client/filecache/FileCache.java <==
package cloud.yogurt.client.filecache;

import cloud.yogurt.shared.logging.Logger;

import java.util.HashMap;
import java.util.Map;

/**
 * A simple client side cache for content of file.
 */
public class FileCache {
    private static Logger log = Logger.getLogger(FileCache.class.getName());

    private Map<String, byte[]> fileContent = new HashMap<>();
    private Map<String, Long> modifyTime = new HashMap<>();
    private Map<String, Long> syncTime = new HashMap<>();

    public void updateCache(String file, byte[] data, long updateTime) {
        long currentTime = System.currentTimeMillis() / 1000;

        fileContent.put(file, data);
        modifyTime.put(file, updateTime);
        syncTime.put(file, currentTime);

        log.info("File " + file + "'s cache has been updated. " +
                "Last Update Time: " + updateTime + " " +
                "Sync Time: " + currentTime);
    }

    public void refreshCache(String file) {
        long currentTime = System.currentTimeMillis() / 1000;
        syncTime.put(file, currentTime);
    }

    public long getModifyTime(String file) {
        return modifyTime.get(file);
    }

    public byte[] getCache(String file, int duration) {
        long currentTime = System.currentTimeMillis() / 1000;
        if (fileContent.get(file) != null)  {
            long passed = currentTime - syncTime.get(file);
            if (passed > duration) {
                log.info("TIMEOUT",
                        "Cache was synced " + passed + "s ago.");
                return null;
            }
            log.info("CACHE_HIT", file + " is found in cache. Passed=" + passed);
            return fileContent.get(file);
        }
        return null;
    }

    public boolean hasCache(String file) {
        return fileContent.get(file) != null;
    }

    public void timeoutCache(String file) {
        fileContent.remove(file);
        modifyTime.remove(file);
        syncTime.remove(file);
    }

}

==> ./client/src/main/java/cloud/yogurt/client/remoteserver/CacheUpdateHandler.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.client.filecache.FileCache;
import cloud.yogurt.shared.header.HeaderIntegerValue;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.message.MessageHandler;
import cloud.yogurt.shared.message.ReceivingMessage;

/**
 * File status handler for file status update.
 * Created by shengliangl on 4/10/2016.
 */
public class CacheUpdateHandler implements MessageHandler {
    private Logger log = Logger.getLogger(FileContentHandler.class.getName());

    String filename;
    FileCache cache;
    YogurtServer server;

    public CacheUpdateHandler(String filename, FileCache cache, YogurtServer server) {
        this.filename = filename;
        this.cache = cache;
        this.server = server;
    }

    /**
     * handle check file status
     * @param receivingMessage message received.
     */
    @Override
    public void handleMessage(ReceivingMessage receivingMessage) {
        log.info("Handle file status, and check cache validation.");
        if (receivingMessage.header.getValue("LastModify") != null) {
            log.info("Last update time for file " + filename + " is " +
                    ((HeaderIntegerValue)receivingMessage.header.getValue("LastModify")).getValue());
            if (cache.getModifyTime(filename)
                    != ((HeaderIntegerValue)receivingMessage.header.getValue("LastModify")).getValue()) {
                log.info("Timeout cache for " + filename + ".");
                cache.timeoutCache(filename);
            } else {
                log.info("Refresh cache for " + filename + ".");
                cache.refreshCache(filename);
            }
            server.get(filename);
        } else {
            log.error("Unknown exception.");
            server.releaseServer();
        }
    }
}

==> ./client/src/main/java/cloud/yogurt/client/remoteserver/CheckStatusHandler.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.shared.header.HeaderIntegerValue;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.message.MessageHandler;
import cloud.yogurt.shared.message.ReceivingMessage;

public class CheckStatusHandler implements MessageHandler {
    private Logger log = Logger.getLogger(FileContentHandler.class.getName());

    String filename;
    YogurtServer server;

    public CheckStatusHandler(String filename, YogurtServer server) {
        this.filename = filename;
        this.server = server;
    }


    @Override
    public void handleMessage(ReceivingMessage receivingMessage) {
        log.info("Handle file status, and check cache validation.");
        if (receivingMessage.header.getValue("LastModify") != null) {
            Logger.printRaw("Last update time for file " + filename + " is " +
                    ((HeaderIntegerValue) receivingMessage.header.getValue("LastModify")).getValue());
        } else {
            Logger.printRaw("File does not exist.");
        }
        this.server.releaseServer();
    }
}

==> ./client/src/main/java/cloud/yogurt/client/remoteserver/FileContentHandler.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.client.filecache.FileCache;
import cloud.yogurt.shared.header.HeaderIntegerValue;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.message.MessageHandler;
import cloud.yogurt.shared.message.ReceivingMessage;
import cloud.yogurt.shared.network.Packet;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

/**
 * Handle the content of file received from the server.
 */
public class FileContentHandler implements MessageHandler {
    private Logger log = Logger.getLogger(FileContentHandler.class.getName());

    String filename;
    FileCache cache;
    YogurtServer server;
    boolean isLimited;

    public FileContentHandler(String filename, FileCache cache, YogurtServer server, boolean isLimited) {
        this.filename = filename;
        this.cache = cache;
        this.server = server;
        this.isLimited = isLimited;
    }

    /**
     * Handle the receiving message from the server.
     * @param receivingMessage the message just received.
     */
    @Override
    public void handleMessage(ReceivingMessage receivingMessage) {
        if (receivingMessage.header.getValue("LastModify") != null) {
            if (!this.isLimited) {
                log.info("Handle file content, and update cache.");
                this.cache.updateCache(filename,
                        receivingMessage.payload,
                        ((HeaderIntegerValue)receivingMessage.header.getValue("LastModify")).getValue());
            }
            Logger.printRaw(new String(receivingMessage.payload, SharedConfig.CONTENT_CHARSET));
            this.server.releaseServer();
        } else {
            Logger.printRaw("File does not exist or illegal arguments.");
            this.server.releaseServer();
        }
    }
}

==> ./client/src/main/java/cloud/yogurt/client/remoteserver/MonitorHandler.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.message.MessageHandler;
import cloud.yogurt.shared.message.ReceivingMessage;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

public class MonitorHandler implements MessageHandler {
    private String path;

    public MonitorHandler(String path) {
        this.path = path;
    }

    @Override
    public void handleMessage(ReceivingMessage receivingMessage) {
        Logger.printRaw("File " + path + " is change. New data: ");
        if (receivingMessage.payload != null && receivingMessage.payload.length > 0) {
            Logger.printRaw(new String(receivingMessage.payload, SharedConfig.CONTENT_CHARSET));
        }
    }
}

==> ./client/src/main/java/cloud/yogurt/client/remoteserver/MonitorTimeoutHandler.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.time.TimeoutHandler;

public class MonitorTimeoutHandler implements TimeoutHandler {
    private static Logger log = Logger.getLogger(MonitorTimeoutHandler.class.getName());

    private final YogurtServer server;

    public MonitorTimeoutHandler(YogurtServer server) {
        this.server = server;
    }

    @Override
    public void handleTimeout() {
        log.info("Finished monitoring.");
        this.server.releaseServer();
    }
}

==> ./client/src/main/java/cloud/yogurt/client/remoteserver/OperationCallHandler.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.message.MessageHandler;
import cloud.yogurt.shared.message.ReceivingMessage;

public class OperationCallHandler implements MessageHandler {
    private YogurtServer server;

    OperationCallHandler(YogurtServer server) {
        this.server = server;
    }

    @Override
    public void handleMessage(ReceivingMessage receivingMessage) {
        if (receivingMessage.header.getParams()[1].equals("SUCCESS")) {
            Logger.printRaw("Operation succeed.");
        } else {
            Logger.printRaw("Operation failed.");
        }
        this.server.releaseServer();
    }
}

==> ./client/src/main/java/cloud/yogurt/client/remoteserver/RemoteServer.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.client.servicecall.ServiceCall;
import cloud.yogurt.shared.message.MessageHandler;
import cloud.yogurt.shared.message.MessageServer;
import cloud.yogurt.shared.network.DatagramServer;
import cloud.yogurt.shared.network.EndPoint;
import cloud.yogurt.shared.network.PacketException;

import java.io.IOException;
import java.net.InetAddress;

/**
 * A class representing the remote server of the client.
 */
public class RemoteServer extends EndPoint {
    private MessageServer messageServer;
    private ServerMessageHandler messageHandler;

    public RemoteServer(InetAddress address, int port) {
        this.address = address;
        this.port = port;

        this.messageHandler = new ServerMessageHandler();

        this.messageServer = new MessageServer() {
            @Override
            public MessageHandler getMessageHandler() {
                return messageHandler;
            }
        };
        this.messageServer.start();
    }

    public int makeServiceCall(ServiceCall serviceCall) {
        serviceCall.setTarget(this);
        this.messageServer.sendMessage(serviceCall);
        return serviceCall.getCallId();
    }

    public void stop() {
        this.messageServer.stopServer();
    }

    public ServerMessageHandler getMessageHandler() {
        return messageHandler;
    }
}

==> ./client/src/main/java/cloud/yogurt/client/remoteserver/ServerMessageHandler.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.message.MessageHandler;
import cloud.yogurt.shared.message.ReceivingMessage;
import cloud.yogurt.shared.network.PacketException;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * Handle the message from server.
 */
public class ServerMessageHandler implements MessageHandler {
    private static Logger log = Logger.getLogger(ServerMessageHandler.class.getName());

    private Map<Integer, MessageHandler> handlers = new HashMap<>();

    @Override
    public void handleMessage(ReceivingMessage receivingMessage) {
        log.debug("Receive message from server.");
        log.debug("Message header:\n" + receivingMessage.header.toString());

        String result = new String(receivingMessage.payload, SharedConfig.CONTENT_CHARSET);
        log.debug("Server Response:\n" + result);

        if (handlers.get(receivingMessage.callId) != null) {
            handlers.get(receivingMessage.callId).handleMessage(receivingMessage);
        }
    }

    public void registerHandler(int callId, MessageHandler serverMessageHandler) {
        handlers.put(callId, serverMessageHandler);
    }
}

==> ./client/src/main/java/cloud/yogurt/client/remoteserver/YogurtServer.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.client.filecache.FileCache;
import cloud.yogurt.client.servicecall.*;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.sharedconfig.SharedConfig;
import cloud.yogurt.shared.time.SetTimeout;

import java.net.InetAddress;

public class YogurtServer {
    private static Logger log = Logger.getLogger(YogurtServer.class.getName());

    public YogurtServer(InetAddress address, int port) {
        server = new RemoteServer(address, port);
    }

    private static RemoteServer server;

    private FileCache fileCache = new FileCache();

    private boolean serverBusy = false;

    public void releaseServer() {
        serverBusy = false;
    }

    public boolean isServerBusy() {
        return serverBusy;
    }

    public void get(String path) {
        log.info("Trying to get " + path + " from server.");
        serverBusy = true;
        byte[] cached = fileCache.getCache(path, 10);
        if (cached == null) {
            if (fileCache.hasCache(path)) {
                // Has invalid cache.
                int callId = makeServiceCall(new CheckFileStatus(path));
                CacheUpdateHandler fileStatusHandler = new CacheUpdateHandler(path, fileCache, this);
                server.getMessageHandler().registerHandler(callId, fileStatusHandler);
            } else {
                // Not cached at all.
                int callId = makeServiceCall(new GetFileByPath(path));
                FileContentHandler fileContentHandler = new FileContentHandler(path, fileCache, this, false);
                server.getMessageHandler().registerHandler(callId, fileContentHandler);
            }
        } else {
            Logger.printRaw(new String(cached, SharedConfig.CONTENT_CHARSET));
            serverBusy = false;
        }
    }


    public void get(String path, int offset, int limit) {
        byte[] cached = fileCache.getCache(path, 10);
        if (cached != null) {
            log.info("Trying to get " + path + " from cache.");
            try {
                if (offset + limit > cached.length) {
                    limit = Math.max(0, cached.length - offset);
                }
                byte[] partial = new byte[limit];
                System.arraycopy(cached, offset, partial, 0, limit);
                Logger.printRaw(new String(partial, SharedConfig.CONTENT_CHARSET));
            } catch (java.lang.ArrayIndexOutOfBoundsException ignored) {
                Logger.printRaw("Illegal parameter.");
            }
        } else {
            log.info("Trying to get " + path + " from server.");
            serverBusy = true;
            int callId = makeServiceCall(new GetFileByPath(path, offset, limit));
            FileContentHandler fileContentHandler = new FileContentHandler(path, fileCache, this, true);
            server.getMessageHandler().registerHandler(callId, fileContentHandler);
        }
    }

    public void insert(String path, int offset, String fragment) {
        log.info("Trying to insert " + fragment + " to " + path + ".");
        serverBusy = true;
        int callId = makeServiceCall(new InsertFragment(path, offset, fragment));
        server.getMessageHandler().registerHandler(callId, new OperationCallHandler(this));
    }

    public void monitor(String path, int duration) {
        log.info("Monitor " + path + ".");
        serverBusy = true;
        int callId = makeServiceCall(new MonitorFileChange(path, duration));
        server.getMessageHandler().registerHandler(callId, new MonitorHandler(path));
        SetTimeout.setTimeout(new MonitorTimeoutHandler(this), duration * 1000);
    }

    public void delete(String path, int offset, int length) {
        log.info("Trying to delete " + length + " from " + path + " at " + offset + ".");
        serverBusy = true;
        int callId = makeServiceCall(new DeleteRange(path, offset, length));
        server.getMessageHandler().registerHandler(callId, new OperationCallHandler(this));
    }

    public void check(String path) {
        log.info("Trying to check " + path + ".");
        serverBusy = true;
        int callId = makeServiceCall(new CheckFileStatus(path));
        server.getMessageHandler().registerHandler(callId, new CheckStatusHandler(path, this));
    }

    private static int makeServiceCall(ServiceCall call)  {
        return server.makeServiceCall(call);
    }

    public void stop() {
        server.stop();
    }
}

==> ./client/src/main/java/cloud/yogurt/client/servicecall/CheckFileStatus.java <==
package cloud.yogurt.client.servicecall;

import cloud.yogurt.shared.header.Header;

import java.util.ArrayList;

/**
 * Service call to check the status of a file.
 */
public class CheckFileStatus extends ServiceCall {
    public CheckFileStatus(String path) {
        super(new Header(new String[]{"CHECK", path}, new ArrayList<>()));
    }
}

==> ./client/src/main/java/cloud/yogurt/client/servicecall/DeleteRange.java <==
package cloud.yogurt.client.servicecall;

import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.header.HeaderIntegerValue;
import cloud.yogurt.shared.header.HeaderRow;

import java.util.ArrayList;

public class DeleteRange extends ServiceCall {

    public DeleteRange(String path, int offset, int limit) {
        super(new Header(new String[]{"DELETE", path}, new ArrayList<HeaderRow>() {
            {
                add(new HeaderRow("Offset", new HeaderIntegerValue(offset)));
                add(new HeaderRow("Length", new HeaderIntegerValue(limit)));
            }
        }));
    }

}

==> ./client/src/main/java/cloud/yogurt/client/servicecall/GetFileByPath.java <==
package cloud.yogurt.client.servicecall;


import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.header.HeaderIntegerValue;
import cloud.yogurt.shared.header.HeaderRow;

import java.util.ArrayList;

/**
 * Service call to get content of a file.
 */
public class GetFileByPath extends ServiceCall {
    public GetFileByPath(String path) {
        super(new Header(new String[]{"GET", path}, new ArrayList<>()));
    }

    public GetFileByPath(String path, int offset, int limit) {
        super(new Header(new String[]{"GET", path}, new ArrayList<HeaderRow>() {
            {
                add(new HeaderRow("Offset", new HeaderIntegerValue(offset)));
                add(new HeaderRow("Limit", new HeaderIntegerValue(limit)));
            }
        }));

    }
}

==> ./client/src/main/java/cloud/yogurt/client/servicecall/InsertFragment.java <==
package cloud.yogurt.client.servicecall;

import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.header.HeaderIntegerValue;
import cloud.yogurt.shared.header.HeaderRow;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.util.ArrayList;

public class InsertFragment extends ServiceCall {

    private static Logger log = Logger.getLogger(InsertFragment.class.getName());

    public InsertFragment(String path, int offset, String fragment) {
        super(
                new Header(new String[] {"INSERT", path}, new ArrayList<HeaderRow>() {
                    {
                        add(new HeaderRow("Offset", new HeaderIntegerValue(offset)));
                    }
                }),
                fragment.getBytes(SharedConfig.CONTENT_CHARSET)
        );
    }

}

==> ./client/src/main/java/cloud/yogurt/client/servicecall/MonitorFileChange.java <==
package cloud.yogurt.client.servicecall;

import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.header.HeaderIntegerValue;
import cloud.yogurt.shared.header.HeaderRow;

import java.util.ArrayList;

/**
 * Service call to monitor the change of a file.
 */
public class MonitorFileChange extends ServiceCall {
    public MonitorFileChange(String filename, int duration) {
        super(new Header(
                new String[] {"MONITOR", filename},
                new ArrayList<HeaderRow>() {
                    {
                        add(new HeaderRow("Duration", new HeaderIntegerValue(duration)));
                    }
                }
        ));
    }
}

==> ./client/src/main/java/cloud/yogurt/client/servicecall/ServiceCall.java <==
package cloud.yogurt.client.servicecall;

import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.message.*;
import cloud.yogurt.shared.network.EndPoint;

public class ServiceCall extends PayloadSendingMessage {
    private static Logger log = Logger.getLogger(ServiceCall.class.getName());

    private static int nextCallId = 1;
    private int callId;
    private EndPoint serverEndPoint;
    private MessageDataLoader dataLoader;

    public ServiceCall(Header header) {
        super(header);
        callId = nextCallId;
        nextCallId ++;
        dataLoader = new EmptyDataLoader();

        log.debug("Service call header:\n" + header.toString());
    }

    public ServiceCall(Header header, byte[] data) {
        super(header);
        callId = nextCallId;
        nextCallId ++;
        dataLoader = new ByteDataLoader(data);

        log.debug("Service call header:\n" + header.toString());
    }

    @Override
    public MessageDataLoader getPayloadDataLoader() {
        return dataLoader;
    }

    @Override
    public int getCallId() {
        return callId;
    }

    public void setTarget(EndPoint endPoint) {
        this.serverEndPoint = endPoint;
    }

    @Override
    public EndPoint getTarget() {
        return serverEndPoint;
    }
}

==> ./client/src/test/java/cloud/yogurt/client/remoteserver/RemoveServerTest.java <==
package cloud.yogurt.client.remoteserver;

import cloud.yogurt.client.servicecall.GetFileByPath;
import cloud.yogurt.client.servicecall.ServiceCall;
import cloud.yogurt.shared.network.PacketException;
import cloud.yogurt.shared.sharedconfig.SharedConfig;
import org.junit.Test;

import java.io.IOException;

import static org.junit.Assert.*;

public class RemoveServerTest {
    @Test
    public void dummyServiceCall() throws IOException, PacketException {
        ServiceCall call = new GetFileByPath("test.txt");
        assertTrue(call.getMessageDataLoader().available() > 0);
    }

    @Test
    public void makeServiceCall() throws IOException, PacketException {
        ServiceCall call = new GetFileByPath("test.txt");
        RemoteServer server = new RemoteServer(SharedConfig.SERVER_ADDRESS, SharedConfig.SERVER_PORT);
        server.makeServiceCall(call);
    }
}

==> ./server/src/main/java/cloud/yogurt/server/cmd/YogurtServer.java <==
package cloud.yogurt.server.cmd;

import cloud.yogurt.server.serverhost.ServerHost;
import cloud.yogurt.shared.logging.Logger;

import java.io.IOException;

/**
 * Command interface for Yogurt Server application.
 */
public class YogurtServer {

    public static void main(String[] args) throws IOException {
        ServerHost host = ServerHost.getInstance();
        host.run();

        Logger.printRaw("Press any key to stop.");
        int ignored = System.in.read();

        host.stop();
        Logger.printRaw("Bye.");
    }
}

==> ./server/src/main/java/cloud/yogurt/server/dulplicatefilter/DuplicateFilter.java <==
package cloud.yogurt.server.dulplicatefilter;

import cloud.yogurt.shared.network.EndPoint;
import cloud.yogurt.shared.network.EndPointCall;

import java.util.HashMap;
import java.util.Map;

/**
 * A class to filter duplicate service call from the same client.
 */
public class DuplicateFilter {
    private Map<EndPointCall, Long> cache = new HashMap<>();

    public void mark(EndPointCall endPointCall) {
        long time = System.currentTimeMillis() / 1000L;
        cache.put(endPointCall, time);
    }

    public boolean isDuplicate(EndPointCall endPointCall) {
        return cache.get(endPointCall) != null;
    }
}

==> ./server/src/main/java/cloud/yogurt/server/filehost/FileChangeMonitor.java <==
package cloud.yogurt.server.filehost;

import cloud.yogurt.server.serverhost.ServerHost;
import cloud.yogurt.server.serverhost.ServerResponse;
import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.network.EndPoint;
import cloud.yogurt.shared.network.PacketException;
import cloud.yogurt.shared.time.SetTimeout;
import cloud.yogurt.shared.time.TimeoutHandler;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;

/**
 * A class holding information to be executed after file change event.
 */
public class FileChangeMonitor implements TimeoutHandler {
    private static Logger log = Logger.getLogger(FileChangeMonitor.class.getName());

    private FileHost host;
    private EndPoint endPoint;
    private int callId;
    private int duration;
    private String filename;

    FileChangeMonitor(FileHost host, String filename, int duration, EndPoint endPoint, int callId) {
        log.debug("File change monitor is created.");

        this.filename = filename;
        this.duration = duration;
        this.endPoint = endPoint;
        this.callId = callId;
        this.host = host;

        SetTimeout.setTimeout(this, duration * 1000);
    }

    public void fileChange() {
        FileResolver fileResolver = null;
        try {
            fileResolver = new FileResolver(filename);

            ServerHost.getInstance().getHostThread().sendMessage(new ServerResponse(
                    callId,
                    new Header(
                            new String[] {"NOTICE", filename},
                            new ArrayList<>()
                    ),
                    fileResolver,
                    endPoint
            ));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void handleTimeout() {
        log.info("Remove file change monitor for file " + filename + " to " + endPoint.toString()
                + " after " + duration);
        host.removeMonitor(filename, this);
    }
}

==> ./server/src/main/java/cloud/yogurt/server/filehost/FileHost.java <==
package cloud.yogurt.server.filehost;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.network.EndPoint;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interfaces for all file related APIs.
 */
public class FileHost {
    private static Logger log = Logger.getLogger(FileHost.class.getName());

    private Map<String, List<FileChangeMonitor>> monitors = new HashMap<>();

    public void removeMonitor(String file, FileChangeMonitor monitor) {
        if (monitors.get(file) != null) {
            monitors.get(file).remove(monitor);
        }
    }

    public FileResolver get(String filename) throws FileNotFoundException {
        return new FileResolver(filename);
    }

    public FileResolver get(String filename, long offset, long limit) throws FileNotFoundException, FileHostException {
        FileResolver fileResolver = new FileResolver(filename);
        long actualSkipped;
        try {
            actualSkipped = fileResolver.skip(offset);
        } catch (IOException e) {
            throw new FileHostException(100, "Cannot read file.");
        }
        if (actualSkipped != offset) {
            throw new FileHostException(101, "Cannot skip file.");
        }
        fileResolver.setLimit(limit + offset);
        return fileResolver;
    }

    public void insert(String filename, int offset, byte[] fragment) throws IOException {
        log.debug("Insert " + new String(fragment, SharedConfig.CONTENT_CHARSET) + " into " + filename +
                " offset " + offset);

        File file = new File(SharedConfig.SERVER_BASE_PATH + "/" + filename);
        byte[] data;
        try {
           data = Files.readAllBytes(file.toPath());
        } catch (NoSuchFileException e) {
            data = new byte[0];
        }
        byte[] modified = new byte[data.length + fragment.length];

        System.arraycopy(data, 0, modified, 0, offset);
        System.arraycopy(fragment, 0, modified, offset, fragment.length);
        System.arraycopy(data, offset, modified, offset + fragment.length, data.length - offset);

        Files.write(file.toPath(), modified);

        notifyMonitor(filename);
    }

    private void notifyMonitor(String filename) {
        if (monitors.get(filename) != null) {
            monitors.get(filename).forEach(FileChangeMonitor::fileChange);
        }
    }

    public void monitor(String filename, int duration, EndPoint endPoint, int callId) {
        log.info("Start monitor " + filename + " from " + endPoint + ".");

        if (monitors.get(filename) == null) {
            monitors.put(filename, new ArrayList<>());
        }
        monitors.get(filename).add(new FileChangeMonitor(this, filename, duration, endPoint, callId));
    }

    public void delete(String filename, int offset, int length) throws IOException {
        log.info("Delete " + filename + " from " + offset + " for " + length + ".");

        File file = new File(SharedConfig.SERVER_BASE_PATH + "/" + filename);
        byte[] data = Files.readAllBytes(file.toPath());
        byte[] modified = new byte[data.length - length];

        System.arraycopy(data, 0, modified, 0, offset);
        System.arraycopy(data, offset + length, modified, offset, data.length - offset - length);

        Files.write(file.toPath(), modified);

        notifyMonitor(filename);
    }

    public long getLastModify(String filename) {
        File file = new File(SharedConfig.SERVER_BASE_PATH + "/" + filename);
        return file.lastModified() / 1000;
    }
}

==> ./server/src/main/java/cloud/yogurt/server/filehost/FileHostException.java <==
package cloud.yogurt.server.filehost;

import cloud.yogurt.shared.common.YogurtException;

public class FileHostException extends YogurtException {
    public FileHostException(int error, String message) {
        super(error, "FileHostException: " + message);
    }
}

==> ./server/src/main/java/cloud/yogurt/server/filehost/FileResolver.java <==
package cloud.yogurt.server.filehost;

import cloud.yogurt.shared.message.MessageDataLoader;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

/**
 * A data loader for file in file host.
 */
public class FileResolver extends MessageDataLoader {

    private long hasRead = 0;
    private long limit = Long.MAX_VALUE;
    private File file;
    private FileInputStream fileInputStream;

    public FileResolver(String path) throws FileNotFoundException {
        file = new File(SharedConfig.SERVER_BASE_PATH + "/" + path);
        fileInputStream = new FileInputStream(file);
    }

    public void setLimit(long limit) {
        this.limit = limit;
    }

    @Override
    public int read() throws IOException {
        hasRead ++;
        if (hasRead > limit) return -1;
        return fileInputStream.read();
    }
}

==> ./server/src/main/java/cloud/yogurt/server/serverhost/ClientMessageHandler.java <==
package cloud.yogurt.server.serverhost;

import cloud.yogurt.server.dulplicatefilter.DuplicateFilter;
import cloud.yogurt.server.filehost.FileHost;
import cloud.yogurt.server.filehost.FileHostException;
import cloud.yogurt.server.filehost.FileResolver;
import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.header.HeaderIntegerValue;
import cloud.yogurt.shared.header.HeaderRow;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.message.EmptyDataLoader;
import cloud.yogurt.shared.message.MessageDataLoader;
import cloud.yogurt.shared.message.MessageHandler;
import cloud.yogurt.shared.message.ReceivingMessage;
import cloud.yogurt.shared.network.EndPointCall;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;

/**
 * The general handler for messages from client.
 */
public class ClientMessageHandler implements MessageHandler {
    private ServerHostThread getServerHostThread () {
        return ServerHost.getInstance().getHostThread();
    }
    private static Logger log = Logger.getLogger(ClientMessageHandler.class.getName());
    private static FileHost fileHost = new FileHost();
    private static DuplicateFilter filter = new DuplicateFilter();

    private void sendMessage(ServerResponse message) {
        this.getServerHostThread().sendMessage(message);
    }

    private void respondClient(ReceivingMessage message, Header header, MessageDataLoader dataLoader) {
        ServerResponse response = new ServerResponse(message.callId, header, dataLoader, message.source);
        this.sendMessage(response);
    }

    private void respondClientSuccess(ReceivingMessage message, MessageDataLoader dataLoader) {
        Header header = new Header(new String[]{"STATUS", "SUCCESS"}, new ArrayList<>());
        respondClient(message, header, dataLoader);
    }

    private void respondClientSuccess(ReceivingMessage message) {
        respondClientSuccess(message, new EmptyDataLoader());
    }

    private void respondClientError(ReceivingMessage message, MessageDataLoader dataLoader) {
        Header header = new Header(new String[]{"STATUS", "ERROR"}, new ArrayList<>());
        respondClient(message, header, dataLoader);
    }

    private void respondClientError(ReceivingMessage message) {
        respondClientError(message, new EmptyDataLoader());
    }

    @Override
    public void handleMessage(ReceivingMessage receivingMessage) {
        EndPointCall endPointCall = new EndPointCall(receivingMessage.source, receivingMessage.callId);

        log.debug("Receive message from client " + endPointCall + ".");

        if (filter.isDuplicate(endPointCall)) {
            log.info("Receive duplicate call " + endPointCall
                    + ". Drop call.");
            return;
        }
        filter.mark(new EndPointCall(receivingMessage.source, receivingMessage.callId));

        String action = receivingMessage.header.getParams()[0];

        switch (action) {
            case "GET": {
                String path = receivingMessage.header.getParams()[1];
                boolean withLimit = false;
                long limit = 0;
                long offset = 0;
                if (receivingMessage.header.getValue("Limit") != null) {
                    limit = ((HeaderIntegerValue)receivingMessage.header.getValue("Limit")).getValue();
                    offset = ((HeaderIntegerValue)receivingMessage.header.getValue("Offset")).getValue();
                    withLimit = true;
                }
                try {
                    FileResolver fileResolver;
                    if (withLimit) {
                        fileResolver = fileHost.get(path, offset, limit);
                    } else {
                        fileResolver = fileHost.get(path);
                    }

                    Header header = new Header(new String[]{"STATUS", "SUCCESS"}, new ArrayList<HeaderRow>(){
                        {
                            {
                                add(new HeaderRow("LastModify",
                                        new HeaderIntegerValue( fileHost.getLastModify(path))));
                            }
                        }
                    });
                    this.respondClient(receivingMessage, header, fileResolver);
                } catch (FileNotFoundException | FileHostException unused) {
                    this.respondClientError(receivingMessage);
                }
                break;
            }
            case "INSERT": {
                String path = receivingMessage.header.getParams()[1];
                int offset = (int)((HeaderIntegerValue)receivingMessage.header.getValue("Offset")).getValue();
                byte[] data = receivingMessage.payload;
                try {
                    fileHost.insert(path, offset, data);
                    this.respondClientSuccess(receivingMessage);
                } catch (Exception e) {
                    e.printStackTrace();
                    this.respondClientError(receivingMessage);
                }
                break;
            }
            case "MONITOR": {
                String path = receivingMessage.header.getParams()[1];
                int duration = (int)((HeaderIntegerValue)receivingMessage.header.getValue("Duration")).getValue();
                fileHost.monitor(path, duration, receivingMessage.source, receivingMessage.callId);
                break;
            }
            case "DELETE": {
                String path = receivingMessage.header.getParams()[1];
                int offset = (int)((HeaderIntegerValue)receivingMessage.header.getValue("Offset")).getValue();
                int length = (int)((HeaderIntegerValue)receivingMessage.header.getValue("Length")).getValue();
                try {
                    fileHost.delete(path, offset, length);
                    this.respondClientSuccess(receivingMessage);
                } catch (Exception e) {
                    this.respondClientError(receivingMessage);
                    e.printStackTrace();
                }
                break;
            }
            case "CHECK": {
                String path = receivingMessage.header.getParams()[1];
                boolean exist;
                try {
                    fileHost.get(path);
                    exist = true;
                } catch (FileNotFoundException unused) {
                    exist = false;
                }
                if (exist) {
                    Header header = new Header(new String[]{"STATUS", "SUCCESS"}, new ArrayList<HeaderRow>() {
                        {
                            add(new HeaderRow("LastModify",
                                    new HeaderIntegerValue( fileHost.getLastModify(path))));
                        }
                    });
                    this.respondClient(receivingMessage, header, new EmptyDataLoader());
                } else {
                    this.respondClientError(receivingMessage);
                }
                break;
            }
        }
    }
}

==> ./server/src/main/java/cloud/yogurt/server/serverhost/ServerHost.java <==
package cloud.yogurt.server.serverhost;

import cloud.yogurt.shared.logging.Logger;

public class ServerHost {

    private static Logger log = Logger.getLogger(ServerHost.class.getName());

    private static ServerHost instance;

    private ServerHostThread hostThread;

    public static ServerHost getInstance() {
        if (instance == null) {
            instance = new ServerHost();
        }
        return instance;
    }

    public void run() {
        log.info("Server is being started.");
        hostThread = new ServerHostThread();
        hostThread.start();
    }

    public void stop() {
        log.info("Server is being stopped.");
        hostThread.stopServer();
    }

    public ServerHostThread getHostThread() {
        return hostThread;
    }
}

==> ./server/src/main/java/cloud/yogurt/server/serverhost/ServerHostThread.java <==
package cloud.yogurt.server.serverhost;

import cloud.yogurt.shared.message.MessageHandler;
import cloud.yogurt.shared.message.MessageServer;
import cloud.yogurt.shared.network.DatagramServer;
import cloud.yogurt.shared.network.PacketHandler;

import static cloud.yogurt.shared.sharedconfig.SharedConfig.*;

/**
 * Main thread for server host served as message server.
 */
public class ServerHostThread extends MessageServer {

    private ClientMessageHandler messageHandler;

    @Override
    public MessageHandler getMessageHandler() {
        return messageHandler;
    }

    public ServerHostThread() {
        super(SERVER_PORT);
        messageHandler = new ClientMessageHandler();
    }
}

==> ./server/src/main/java/cloud/yogurt/server/serverhost/ServerResponse.java <==
package cloud.yogurt.server.serverhost;

import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.message.MessageDataLoader;
import cloud.yogurt.shared.message.PayloadSendingMessage;
import cloud.yogurt.shared.network.EndPoint;

/**
 * Sending message constructor for response to the client.
 */
public class ServerResponse extends PayloadSendingMessage {

    private int callId;
    private MessageDataLoader dataLoader;
    private EndPoint endPoint;


    public ServerResponse(int callId, Header header, MessageDataLoader dataLoader, EndPoint target) {
        super(header);
        this.callId = callId;
        this.dataLoader = dataLoader;
        this.endPoint = target;
    }

    @Override
    public MessageDataLoader getPayloadDataLoader() {
        return dataLoader;
    }

    @Override
    public int getCallId() {
        return callId;
    }

    @Override
    public EndPoint getTarget() {
        return this.endPoint;
    }
}

==> ./server/src/test/java/cloud/yogurt/server/filehost/FileResolverTest.java <==
package cloud.yogurt.server.filehost;

import cloud.yogurt.shared.sharedconfig.SharedConfig;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

import static org.junit.Assert.*;

public class FileResolverTest {
    String LINE_1 = "Line 1.";
    String LINE_2 = "Line 2.";

    @Before
    public void prepareFile() throws FileNotFoundException, UnsupportedEncodingException {
        String serverBasePath = SharedConfig.SERVER_BASE_PATH;
        File baseDirectory = new File(serverBasePath);
        if (!baseDirectory.exists()) {
            boolean result = baseDirectory.mkdir();
            assertTrue(result);
        }
        File textFile = new File(serverBasePath + "/test.txt");
        PrintWriter writer = new PrintWriter(textFile, String.valueOf(SharedConfig.CONTENT_CHARSET));
        writer.println(LINE_1);
        writer.println(LINE_2);
        writer.close();
    }

    @Test
    public void readWholeFile() throws IOException {
        int maxFileSize = 1000;
        byte[] buffer = new byte[maxFileSize];
        FileResolver fileResolver = new FileResolver("test.txt");
        int fileSize = fileResolver.read(buffer);
        byte[] stringInBytes = new byte[fileSize];
        System.arraycopy(buffer, 0, stringInBytes, 0, fileSize);
        assertEquals(new String(stringInBytes, SharedConfig.CONTENT_CHARSET), LINE_1 + "\n" + LINE_2 + "\n");
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/common/YogurtException.java <==
package cloud.yogurt.shared.common;

/**
 * Yogurt Exception extends exceptions
 */
public class YogurtException extends Exception {
    private int error;

    public YogurtException() {
        super("[YogurtException]");
    }

    public YogurtException(String s) {
        super("[YogurtException] " + s);
    }

    public YogurtException(int error, String s) {
        super("[YogurtException] " + s);
    }

    public int getError(){
        return error;
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/header/Header.java <==
package cloud.yogurt.shared.header;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.util.ArrayList;
import java.util.List;

/**
 * Header class
 * Used to add at beginning of Packetss
 */
public class Header {
    private static Logger log = Logger.getLogger(Header.class.getName());

    private String[] params;
    private  List<HeaderRow> headerRows;

    public Header(String[] params, List<HeaderRow> headerRows) {
        this.params = params;
        this.headerRows = headerRows;
    }

    public String[] getParams() {
        return this.params;
    }

    /**
     * Get value of certain key in passed message
     * @param key
     * @return
     */
    public HeaderValue getValue(String key) {
        for (HeaderRow row : headerRows) {
            if (row.key.equals(key)) {
                return row.value;
            }
        }
        return null;
    }


    /**
     * Use simple append to contruct string content of header
     * add new line for each row
     * @return flatten header
     */
    @Override
    public String toString() {
        StringBuffer headerString = new StringBuffer(SharedConfig.CURRENT_API_VERSION);
        for (String param: params) {
            headerString.append(' ');
            headerString.append(param);
        }
        headerString.append('\n');
        for (HeaderRow row : headerRows) {
            headerString.append(row.toString());
            headerString.append('\n');
        }
        headerString.append('\n');

        return headerString.toString();
    }


    /**
     * Get header from passed string
     * @param string
     * @return header object
     */
    public static Header fromString(String string) {
        String[] lines = string.split("\n");
        String[] firstLines = lines[0].split(" ");
        String[] params = new String[firstLines.length - 1];
        System.arraycopy(firstLines, 1, params, 0, firstLines.length - 1);
        List<HeaderRow> rows = new ArrayList<>();
        for (int i = 1; i < lines.length; i ++) {
            if (lines[i].length() > 0) {
                String[] keyValuePair = lines[i].split(": ");
                String key = keyValuePair[0];
                String value = keyValuePair[1];
                HeaderValue headerValue;
                try {
                    long intValue = Long.parseUnsignedLong(value);
                    headerValue = new HeaderIntegerValue(intValue);
                } catch (NumberFormatException ignored) {
                    headerValue = new HeaderStringValue(value);
                }
                rows.add(new HeaderRow(key, headerValue));
            }
        }
        Header header = new Header(params, rows);
        return header;
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/header/HeaderIntegerValue.java <==
package cloud.yogurt.shared.header;

/**
 * Integer value in headers
 */
public class HeaderIntegerValue extends HeaderValue {
    private long value;

    public HeaderIntegerValue(long value) {
        this.value = value;
    }
    @Override
    public String toString() {
        return "" + this.value;
    }
    public long getValue() {
        return value;
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/header/HeaderRow.java <==
package cloud.yogurt.shared.header;

/**
 * Passed parameters are listed in rows
 * With format of key and value pairs
 */
public class HeaderRow {
    public String key;
    public HeaderValue value;

    public HeaderRow(String key, HeaderValue value) {
        this.key = key;
        this.value = value;
    }

    @Override
    public String toString() {
        return key + ": " + value.toString();
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/header/HeaderStringValue.java <==
package cloud.yogurt.shared.header;

/**
 * String value in header
 */
public class HeaderStringValue extends HeaderValue {
    private String value;

    HeaderStringValue(String value) {
        this.value = value;
    }
    @Override
    public String toString() {
        return this.value;
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/header/HeaderValue.java <==
package cloud.yogurt.shared.header;

/**
 * Empty parent class
 */
public class HeaderValue {
}

==> ./shared/src/main/java/cloud/yogurt/shared/logging/Level.java <==
package cloud.yogurt.shared.logging;

public enum Level {
    DEBUG,
    INFO,
    WARNING,
    ERROR
}

==> ./shared/src/main/java/cloud/yogurt/shared/logging/Logger.java <==
package cloud.yogurt.shared.logging;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Logger used by all Yogurt classes.
 */
public class Logger {
    public static boolean silent = false;

    private String name;

    private Logger(String name) {
        this.name = name;
    }

    private static String getLogLevelName(Level level) {
        return level.name();
    }

    private static String getCurrentTime() {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
        Date now = new Date();
        return simpleDateFormat.format(now);
    }

    public synchronized void log(Level level, String tag, String message) {
        StringBuilder logString = new StringBuilder();
        logString.append(getCurrentTime());
        logString.append(" ");
        logString.append(getLogLevelName(level));
        logString.append(" ");
        logString.append(name);
        logString.append(" ");
        if (tag != null) {
            logString.append("[");
            logString.append(tag);
            logString.append("] ");
        }
        logString.append(message);
        if (!silent) {
            System.err.println("# " + logString.toString());
            System.err.flush();
        }
    }

    public void debug(String tag, String message) {
        log(Level.DEBUG, tag, message);
    }

    public void debug(String message) {
        log(Level.DEBUG, null, message);
    }

    public void info(String tag, String message) {
        log(Level.INFO, tag, message);
    }

    public void info(String message) {
        log(Level.INFO, null, message);
    }

    public void warn(String tag, String message) {
        log(Level.WARNING, tag, message);
    }

    public void warn(String message) {
        log(Level.WARNING, null, message);
    }

    public void error(String tag, String message) {
        log(Level.ERROR, tag, message);
    }

    public void error(String message) {
        log(Level.ERROR, null, message);
    }

    public static Logger getLogger(String name) {
        return new Logger(name);
    }

    public static void printRaw(String s) {
        System.out.println(s);
        System.out.flush();
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/ByteDataLoader.java <==
package cloud.yogurt.shared.message;

import java.io.ByteArrayInputStream;
import java.io.IOException;

/**
 * ByteData format message loader
 */
public class ByteDataLoader extends MessageDataLoader {
    private ByteArrayInputStream byteArrayInputStream;

    public ByteDataLoader(byte[] data) {
        byteArrayInputStream = new ByteArrayInputStream(data);
    }

    @Override
    public int read() throws IOException {
        return byteArrayInputStream.read();
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/CombineDataLoader.java <==
package cloud.yogurt.shared.message;

import java.io.IOException;
import java.io.SequenceInputStream;

/**
 * combine data loader for two message format data
 */
public class CombineDataLoader extends MessageDataLoader {
    SequenceInputStream sequenceInputStream;

    public CombineDataLoader(MessageDataLoader loader1, MessageDataLoader loader2) {
        sequenceInputStream = new SequenceInputStream(loader1, loader2);
    }

    @Override
    public int read() throws IOException {
        return sequenceInputStream.read();
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/EmptyDataLoader.java <==
package cloud.yogurt.shared.message;

import java.io.IOException;

public class EmptyDataLoader extends MessageDataLoader {
    @Override
    public int read() throws IOException {
        return -1;
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/HeaderDataLoader.java <==
package cloud.yogurt.shared.message;

import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.io.ByteArrayInputStream;
import java.io.IOException;

/**
 * Message data loader for packet header
 */
public class HeaderDataLoader extends MessageDataLoader {
    private ByteArrayInputStream byteInputStream;

    public HeaderDataLoader(Header header) {
        String headerAsString = header.toString();
        byte[] headerAsByte = headerAsString.getBytes(SharedConfig.HEADER_CHARSET);
        byteInputStream = new ByteArrayInputStream(headerAsByte);
    }

    @Override
    public int read() throws IOException {
        return byteInputStream.read();
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/MessageDataLoader.java <==
package cloud.yogurt.shared.message;

import java.io.InputStream;
/**
 * abstrct class that extends InputSteam Class for data streaming
 */
public abstract class MessageDataLoader extends InputStream {
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/MessageException.java <==
package cloud.yogurt.shared.message;

import cloud.yogurt.shared.common.YogurtException;

public class MessageException extends YogurtException {
    public MessageException(String s) {
        super("MessageException: " + s);
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/MessageHandler.java <==
package cloud.yogurt.shared.message;

public interface MessageHandler {
    void handleMessage(ReceivingMessage receivingMessage);
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/MessagePacketHandler.java <==
package cloud.yogurt.shared.message;

import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.network.EndPoint;
import cloud.yogurt.shared.network.Packet;
import cloud.yogurt.shared.network.PacketException;
import cloud.yogurt.shared.network.PacketHandler;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class MessagePacketHandler implements PacketHandler {

    private static Logger log = Logger.getLogger(MessagePacketHandler.class.getName());

    private MessageServer server;

    List<Packet> receiveBuffer = new ArrayList<>();

    public MessagePacketHandler(MessageServer server) {
        this.server = server;
    }

    @Override
    public void handlePacket(Packet packet) {
        receiveBuffer.add(packet);
        if (packet.eomFlag) {
            consumePackets();
        }
    }

    /**
     * Consume an sequence of received packets.
     */
    synchronized private void consumePackets() {
        int dataSize = 0;
        for (Packet packet : receiveBuffer) {
            dataSize += packet.content.length;
        }
        byte[] data = new byte[dataSize];
        int pos = 0;

        for (Packet packet : receiveBuffer) {
            System.arraycopy(packet.content, 0, data, pos, packet.content.length);
            pos += packet.content.length;
        }

        log.info("Total message length: " + data.length);

        int payloadOffset = 0;
        boolean previousNewLine = false;
        StringBuilder headerString = new StringBuilder();

        for (int i = 0; i < data.length; i += 2) {
            byte[] nextChar = new byte[2];
            nextChar[0] = data[i];
            nextChar[1] = data[i+1];
            String partial = new String(nextChar, SharedConfig.HEADER_CHARSET);
            headerString.append(partial);
            if (partial.equals("\n")) {
                if (previousNewLine) {
                    payloadOffset = i + 2;
                    break;
                } else {
                    previousNewLine = true;
                }
            } else {
                previousNewLine = false;
            }
        }

        Header header = Header.fromString(headerString.toString());

        byte[] payload = new byte[dataSize - payloadOffset];
        System.arraycopy(data, payloadOffset, payload, 0, payload.length);

        int callId = receiveBuffer.get(receiveBuffer.size() - 1).callId;
        EndPoint source = receiveBuffer.get(receiveBuffer.size() - 1).endPoint;

        ReceivingMessage message = new ReceivingMessage(callId, source, header, payload);
        server.getMessageHandler().handleMessage(message);

        receiveBuffer.clear();
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/MessageSender.java <==
package cloud.yogurt.shared.message;

public interface MessageSender {
    void sendMessage(SendingMessage message) throws MessageException;
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/MessageServer.java <==
package cloud.yogurt.shared.message;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.network.DatagramServer;
import cloud.yogurt.shared.network.Packet;
import cloud.yogurt.shared.network.PacketException;
import cloud.yogurt.shared.network.PacketHandler;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Message server that acts as a wrapper of UDP servers
 */
public abstract class MessageServer extends DatagramServer implements MessageSender {
    private MessagePacketHandler messagePacketHandler = null;
    private static Logger log = Logger.getLogger(MessageServer.class.getName());

    public abstract MessageHandler getMessageHandler();

    public MessageServer() {
        super();
    }

    public MessageServer(int port) {
        super(port);
    }

    @Override
    protected PacketHandler getPacketHandler() {
        if (messagePacketHandler == null) {
            messagePacketHandler = new MessagePacketHandler(this);
        }
        return messagePacketHandler;
    }
    /**
     * Create thread and send message
     * @param message message to send
     */
    public void sendMessage(SendingMessage message) {
        SendMessageThread sendMessageThread = new SendMessageThread(message, this);
        sendMessageThread.start();
    }

}

==> ./shared/src/main/java/cloud/yogurt/shared/message/NonPayloadSendingMessage.java <==
package cloud.yogurt.shared.message;

import cloud.yogurt.shared.header.Header;

public abstract class NonPayloadSendingMessage extends PayloadSendingMessage {
    public NonPayloadSendingMessage(Header header) {
        super(header);
    }

    @Override
    public MessageDataLoader getPayloadDataLoader() {
        return new EmptyDataLoader();
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/PayloadSendingMessage.java <==
package cloud.yogurt.shared.message;

import java.io.IOException;
import java.io.SequenceInputStream;
import cloud.yogurt.shared.header.Header;

/**
 * Payload message sending with combined data loader
 */
public abstract class PayloadSendingMessage extends SendingMessage {
    private Header header;

    public PayloadSendingMessage(Header header) {
        this.header = header;
    }

    public abstract MessageDataLoader getPayloadDataLoader();

    public MessageDataLoader getMessageDataLoader() {
        HeaderDataLoader headerDataLoader = new HeaderDataLoader(header);
        return new CombineDataLoader(headerDataLoader, getPayloadDataLoader());
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/ReceivingMessage.java <==
package cloud.yogurt.shared.message;

import cloud.yogurt.shared.header.Header;
import cloud.yogurt.shared.network.EndPoint;

public class ReceivingMessage {
    public int callId;
    public EndPoint source;
    public Header header;
    public byte[] payload;

    public ReceivingMessage(int callId, EndPoint endPoint, Header header, byte[] payload) {
        this.callId = callId;
        this.source = endPoint;
        this.header = header;
        this.payload = payload;
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/SendingMessage.java <==
package cloud.yogurt.shared.message;

import cloud.yogurt.shared.network.EndPoint;
import cloud.yogurt.shared.network.Packet;
import cloud.yogurt.shared.network.PacketSender;

import java.util.ArrayList;
import java.util.List;

/**
 * provides basic functionality for creating messages to send.
 *
 */
public abstract class SendingMessage {
    public abstract int getCallId();
    public abstract EndPoint getTarget();
    public abstract MessageDataLoader getMessageDataLoader();
}

==> ./shared/src/main/java/cloud/yogurt/shared/message/SendMessageThread.java <==
package cloud.yogurt.shared.message;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.network.DatagramServer;
import cloud.yogurt.shared.network.Packet;
import cloud.yogurt.shared.network.PacketException;
import cloud.yogurt.shared.sharedconfig.SharedConfig;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Message sending thread class that is used to send message 
 * in a muli-threading mannaer
 */
public class SendMessageThread extends Thread {
    private SendingMessage message;
    private DatagramServer server;
    public SendMessageThread(SendingMessage message, DatagramServer server) {
        this.message = message;
        this.server = server;
    }

    private static Logger log = Logger.getLogger(SendMessageThread.class.getName());

    /**
     * Send message execution
     * Chunk message if exceeds MAX_PACKET_PAYLOAD
     */
    public void run() {
        try {
            log.info("Send message to " + message.getTarget().address + ":" + message.getTarget().port + ".");
            MessageDataLoader loader = message.getMessageDataLoader();
            List<Packet> packets = new ArrayList<>();
            while (true) {
                Packet packet = new Packet();
                packet.callId = message.getCallId();
                packet.endPoint = message.getTarget();
                byte[] buffer = new byte[SharedConfig.MAX_PACKET_PAYLOAD];
                int bytesRead = loader.read(buffer);
                if (bytesRead <= 0) {
                    break;
                } else {
                    log.debug("Read " + bytesRead + " bytes from data loader.");
                    packet.content = new byte[bytesRead];
                    System.arraycopy(buffer, 0, packet.content, 0, bytesRead);
                }
                packets.add(packet);
            }
            packets.get(packets.size() - 1).eomFlag = true;
            for (Packet packet : packets) server.sendPacket(packet);
            log.debug("Finish sending message.");
        } catch (PacketException | IOException e) {
            e.printStackTrace();
        }
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/network/DatagramServer.java <==
package cloud.yogurt.shared.network;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.time.SetTimeout;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

import static cloud.yogurt.shared.sharedconfig.SharedConfig.*;

/**
 * The default sender and receiver for Yogurt packets.
 *
 * Currently the implementation for `sendPacket` is asynchronized, i.e.
 * packet may not be sent after function returns.
 */
public abstract class DatagramServer extends Thread implements PacketSender {

    private static Logger log = Logger.getLogger(DatagramServer.class.getName());

    private boolean isStopped = false;

    private int port;

    private DatagramSocket socket;

    private byte[] receiveBuffer = new byte[MAX_DATAGRAM];
    private DatagramPacket receiveDatagram = new DatagramPacket(receiveBuffer, MAX_DATAGRAM);

    private List<Packet> packetsToSend = new LinkedList<>();

    /**
     * Next packet ID to be used for an endpoint call.
     */
    private Map<EndPointCall, Long> sendId = new HashMap<>();

    /**
     * As a receiver, next packet ID to be received for and endpoint call.
     */
    private Map<EndPointCall, Long> ackId = new HashMap<>();

    /**
     * As a sender, next packet ID to be received by receiver.
     */
    private Map<EndPointCall, Long> receivedId = new HashMap<>();

    /**
     * Receive buffer.
     */
    private Map<EndPointCall, ReceivingBuffer> receivingBuffers = new HashMap<>();

    protected abstract PacketHandler getPacketHandler();

    /**
     * Default constructor without specific port.
     *
     * This constructor is typical used by client, since it does not need to listen on a specific port.
     */
    public DatagramServer() {
        this.port = 0;
    }

    /**
     * The constructor with a specific port.
     *
     * @param port Which port would the server be listening on.
     */
    public DatagramServer(int port) {
        this.port = port;
    }

    @Override
    public void run() {
        try {
            if (this.port != 0) {
                socket = new DatagramSocket(port);
            } else {
                // Create socket in any port.
                socket = new DatagramSocket();
            }
        } catch (SocketException e) {
            e.printStackTrace();
        }
        log.info("Socket server is listening at port " + socket.getLocalPort());
        while (!isStopped) {
            waitForDatagram();
        }
    }

    public void stopServer() {
        log.debug("Stopping datagram server on port " + this.socket.getLocalPort() + ".");
        isStopped = true;
        if (socket != null && !socket.isClosed()) {
            socket.close();
        }
    }

    /**
     * Server waits for user datagram
     *  with message control
     */
    private void waitForDatagram() {
        log.debug("Waiting for incoming datagram.");

        try {
            socket.receive(receiveDatagram);
            byte[] buffer = new byte[receiveDatagram.getLength()];
            System.arraycopy(receiveDatagram.getData(), 0, buffer, 0, buffer.length);
            Packet packet = new Packet();
            packet.decodeDatagram(buffer);
            packet.endPoint = new EndPoint();
            packet.endPoint.address = receiveDatagram.getAddress();
            packet.endPoint.port = receiveDatagram.getPort();

            log.debug("Receive packet " + packet.toString());

            EndPointCall endPointCall = new EndPointCall(packet);

            setReceivedId(endPointCall, packet.ackPacket);

            if (packet.ackFlag) {
                // Pure ACK packet. NO need to process.
                return;
            }

            if (getAckId(endPointCall) == packet.id) {
                // The packet is exactly what we want.
                setAckId(endPointCall, packet.id);
                getPacketHandler().handlePacket(packet);
                sendAck(packet.endPoint, packet.callId);

                ReceivingBuffer receivingBuffer = receivingBuffers.get(endPointCall);

                if (receivingBuffer != null) {
                    while(receivingBuffer.peek() != null) {
                        Packet bufferedPacket = receivingBuffer.peek();
                        if (getAckId(endPointCall) == bufferedPacket.id) {
                            getPacketHandler().handlePacket(bufferedPacket);
                            setAckId(endPointCall, bufferedPacket.id);
                            receivingBuffer.poll();
                        } else if (getAckId(endPointCall) > bufferedPacket.id) {
                            // The packet is useless.
                            receivingBuffer.poll();
                        } else {
                            // The packet is for the future.
                            break;
                        }
                    }
                }

            } else if (getAckId(endPointCall) < packet.id) {
                // The packet is for the future.
                if (receivingBuffers.get(endPointCall) == null) {
                    receivingBuffers.put(endPointCall, new ReceivingBuffer());
                }
                ReceivingBuffer receivingBuffer = receivingBuffers.get(endPointCall);
                receivingBuffer.add(packet);
            } else {
                log.debug("Packet is dropped, since it's been received.");
                sendAck(packet.endPoint, packet.callId);
            }

        }
        catch (SocketException sc) {
            log.error("Socket server is closed.");
        }
        catch (IOException | PacketException e) {
            e.printStackTrace();
        }

    }

    private long getSendId(EndPoint endPoint, int call) {
        EndPointCall endPointCall = new EndPointCall(endPoint, call);
        if (sendId.get(endPointCall) != null) {
            sendId.put(endPointCall, sendId.get(endPointCall) + 1);
        }
        else {
            sendId.put(endPointCall, 1l);
        }
        return sendId.get(endPointCall) - 1;
    }

    private long getAckId(EndPointCall endPointCall ) {
        if (ackId.get(endPointCall) != null) {
            return ackId.get(endPointCall);
        }
        return 0;
    }

    /**
     * Store accepted packets from sender locally.
     * @return true only if is receiving next frame.
     */
    private void setAckId(EndPointCall endPointCall, long id) {
        if (getAckId(endPointCall) == id) {
            ackId.put(endPointCall, id + 1);
        }
    }

    /**
     * Simple packet with ACK included
     * @param endPoint to whom the packet is sent to.
     * @param callId call ID of the packet.
     * @throws PacketException
     */
    private void sendAck(EndPoint endPoint, int callId) throws PacketException {
        Packet packet = new Packet();
        packet.callId = callId;
        packet.endPoint = endPoint;
        packet.ackFlag = true;
        sendPacket(packet);
    }

    private long getReceivedId(EndPointCall endPointCall) {
        Long receivedId = this.receivedId.get(endPointCall);
        if (receivedId == null) {
            return 0;
        } else {
            return receivedId;
        }
    }

    private void setReceivedId(EndPointCall endPointCall, long id) {
        if (getReceivedId(endPointCall) < id) {
            log.debug("SET_RECEIVED_ID", "Packet " + id + " i from " + endPointCall);
            this.receivedId.put(endPointCall, id);
        }
    }

    public boolean isPacketReceived(Packet packet) {
        if (getReceivedId(new EndPointCall(packet)) > packet.id) {
            log.debug("CHECK_PACKET_RECEIVED", packet.toString() + " is received.");
            return true;
        }
//        log.debug("CHECK_PACKET_RECEIVED", packet.toString() + " is not received.");
        return false;
    }


    public boolean isNextToSend(Packet packet) {
        return getReceivedId(new EndPointCall(packet)) == packet.id;
    }

    /**
     * Send packet
     *  set packet id
     *      ack packet id
     *  construct packet
     *      log message transmission
     * use datagram socket
     * @param packet reference for packet construction
     * @throws PacketException
     */
    public void sendPacket(Packet packet, int retry) throws PacketException {
        if (packet.id < 0) {
            if (!packet.ackFlag) {
                // We set packet ID to 0 for pure ACK packets.
                // We don't care if they are lost.
                packet.id = getSendId(packet.endPoint, packet.callId);
            }
        }
        packet.ackPacket = getAckId(new EndPointCall(packet.endPoint, packet.callId));
        byte[] constructedPacket = packet.construct();
        DatagramPacket sendingDatagram = new DatagramPacket(constructedPacket, constructedPacket.length);
        sendingDatagram.setAddress(packet.endPoint.address);
        sendingDatagram.setPort(packet.endPoint.port);
        if (!packet.ackFlag) {
            SetTimeout.setTimeout(new ResendPacket(packet, this, retry), RESENT_TIMEOUT);
        }
        try {
            log.info("Send packet " + packet.toString());
            socket.send(sendingDatagram);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    public void sendPacket(Packet packet) throws PacketException {
        sendPacket(packet, 0);
    }

}

==> ./shared/src/main/java/cloud/yogurt/shared/network/EndPoint.java <==
package cloud.yogurt.shared.network;

import java.net.InetAddress;

public class EndPoint {
    public InetAddress address;
    public int port;

    @Override
    public String toString() {
        return address.toString() + ":" + port;
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/network/EndPointCall.java <==
package cloud.yogurt.shared.network;


public class EndPointCall {
    public EndPoint endPoint;
    public int callId;

    public EndPointCall(EndPoint endPoint, int call) {
        this.endPoint = endPoint;
        this.callId = call;
    }

    public EndPointCall(Packet packet) {
        this.endPoint = packet.endPoint;
        this.callId = packet.callId;
    }

    /**
     * Message control packet equal checker
     * @param other
     * @return
     */
    @Override
    public boolean equals(Object other) {
        if (other instanceof EndPointCall) {
            EndPointCall otherCall = (EndPointCall) other;
            if (callId == otherCall.callId &&
                    endPoint.address.equals(otherCall.endPoint.address) &&
                    endPoint.port == otherCall.endPoint.port) {
                return true;
            }
        }
        return false;
    }

    public int hashCode() {
        return callId;
    }

    public String toString() {
        return this.endPoint.toString() + "->" + callId;
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/network/Packet.java <==
package cloud.yogurt.shared.network;

import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import static cloud.yogurt.shared.sharedconfig.SharedConfig.*;

/**
 * Packet class
 *  contains EndPoint indicator
 *  Packet ID, Ack Pack ID;
 *  Call ID, Flags
 *  
 *  Lower layer transmission carrier.
 */
public class Packet {

    public EndPoint endPoint;

    public long id = -1;  // 4 bytes
    public long ackPacket;  // 4 bytes

    public int callId;  // 2 bytes
    public boolean ackFlag;
    public boolean resFlag;
    public boolean eomFlag;

    public byte[] content;

    /**
     * Packet constuction function
     *  takes packet header and content
     * @return datagram packet
     * @throws PacketException
     */
    public byte[] construct() throws PacketException {
        if (content == null) content = new byte[0];
        if (content.length > MAX_PACKET_PAYLOAD) {
            throw new PacketException("Packet payload size too large, actual = " + content.length);
        }

        byte[] datagram = new byte[PACKET_HEADER_SIZE + content.length];
        System.arraycopy(getByteFromInteger(callId, 2), 0, datagram, 0, 2);

        boolean[] bitFlags = new boolean[16];
        bitFlags[0] = resFlag;
        bitFlags[1] = ackFlag;
        bitFlags[2] = eomFlag;
        int bitFlagsInts = constructIntegerWithFlags(bitFlags);
        System.arraycopy(getByteFromInteger(bitFlagsInts, 2), 0, datagram, 2, 2);

        System.arraycopy(getByteFromInteger(id, 4), 0, datagram, 4, 4);
        System.arraycopy(getByteFromInteger(ackPacket, 4), 0, datagram, 8, 4);

        System.arraycopy(content, 0, datagram, 12, content.length);

        return datagram;
    }
    /**
     *
     * @param flags
     * @return
     */
    private int constructIntegerWithFlags(boolean[] flags) {
        int result = 0;
        for (boolean flag : flags) {
            result <<= 1;
            result += flag ? 1 : 0;
        }
        return result;
    }

    /**
     *
     * @param number
     * @param length
     * @return
     */
    private boolean[] getBitFromInteger(int number, int length) {
        boolean[] flags = new boolean[length];
        for (int i = length - 1; i >= 0; i--) {
            flags[i] = number % 2 == 1;
            number /= 2;
        }
        return flags;
    }

    /**
     *
     * @param number
     * @param length
     * @return
     * @throws PacketException
     */
    private byte[] getByteFromInteger(long number, int length) throws PacketException {
        if (number > ((long)1 << (length * 8))) {
            throw new PacketException("Number out of bound. Maximum " + (1 << (length * 8)) + " found " + number);
        }
        byte[] result = new byte[length];
        for (int i = length - 1; i >= 0; i--) {
            result[i] = (byte) (number % (1 << 8));
            number /= 1 << 8;
        }
        return result;
    }

    /**
     * Datagram decode function
     * 
     * @param bytes
     * 
     * return packet message to class abtributes
     */
    public void decodeDatagram(byte[] bytes) {
        this.callId = readIntegerFromByte(bytes, 0, 2);
        if (this.callId == 255) {
            this.callId = -1;
        }
        int flagInteger = readIntegerFromByte(bytes, 2, 2);
        boolean[] flags = getBitFromInteger(flagInteger, 16);
        this.resFlag = flags[0];
        this.ackFlag = flags[1];
        this.eomFlag = flags[2];

        this.id = readIntegerFromByte(bytes, 4, 4);
        this.ackPacket = readIntegerFromByte(bytes, 8, 4);

        int contentLength = bytes.length - PACKET_HEADER_SIZE;
        content = new byte[contentLength];
        System.arraycopy(bytes, 12, content, 0, contentLength);
    }

    /**
     * Decode flatten integer from bytes
     * @param bytes
     * @param start
     * @param length
     * @return integer value
     */
    private int readIntegerFromByte(byte[] bytes, int start, int length) {
        int result = 0;
        for (int i = 0; i < length; i++) {
            result <<= 8;
            result += (int) bytes[i + start] & 0xff;  // Convert to an unsigned byte.
        }
        return result;
    }

    public String toString() {
        return "<Packet " + id + " to " + endPoint + "->" + callId + " size:" + content.length +
                " ack:" + ackPacket + ">";
    }

}

==> ./shared/src/main/java/cloud/yogurt/shared/network/PacketException.java <==
package cloud.yogurt.shared.network;

import cloud.yogurt.shared.common.YogurtException;

public class PacketException extends YogurtException {
    public PacketException(String s) {
        super("PacketException: " + s);
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/network/PacketHandler.java <==
package cloud.yogurt.shared.network;

public interface PacketHandler {

    void handlePacket(Packet packet);

}

==> ./shared/src/main/java/cloud/yogurt/shared/network/PacketSender.java <==
package cloud.yogurt.shared.network;

import cloud.yogurt.shared.network.Packet;
import cloud.yogurt.shared.network.PacketException;

/**
 * Interface for anything that can send packets.
 *
 * The implementation of such sender should maintain a queue itself, if the
 * `sendPacket` action is not synchronous.
 */
public interface PacketSender {
    void sendPacket(Packet packet) throws PacketException;
}

==> ./shared/src/main/java/cloud/yogurt/shared/network/ReceivingBuffer.java <==
package cloud.yogurt.shared.network;

import java.util.Comparator;
import java.util.PriorityQueue;

public class ReceivingBuffer {
    private static Comparator<Packet> packetIdComparator = (left, right) -> {
        if (left.id > right.id) return 1;
        else if (left.id == right.id) return 0;
        else return -1;
    };

    private PriorityQueue<Packet> packets = new PriorityQueue<>(packetIdComparator);

    public void add(Packet packet) {
        packets.add(packet);
    }

    public Packet peek() {
        return packets.peek();
    }

    public Packet poll() {
        return packets.poll();
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/network/ResendPacket.java <==
package cloud.yogurt.shared.network;

import cloud.yogurt.shared.logging.Logger;
import cloud.yogurt.shared.sharedconfig.SharedConfig;
import cloud.yogurt.shared.time.TimeoutHandler;

public class ResendPacket implements TimeoutHandler {
    private static Logger log = Logger.getLogger(ResendPacket.class.getName());

    private Packet packet;
    private DatagramServer datagramServer;
    private int retry;

    ResendPacket(Packet packet, DatagramServer datagramServer, int retry) {
        this.packet = packet;
        this.datagramServer = datagramServer;
        this.retry = retry;
    }

    @Override
    public void handleTimeout() {
        if (!this.datagramServer.isPacketReceived(this.packet)) {
            try {
                retry ++;
                if (retry > SharedConfig.MAXIMUM_RETRY) {
                    log.error("TIMEOUT", "Unable to send packet " + packet + " after " + retry + " times.");
                    return;
                }
                log.info("TIMEOUT_RESEND", "Resent packet " + packet + " after timeout. Retry = " + retry);
                this.datagramServer.sendPacket(this.packet, retry);
            } catch (PacketException e) {
                e.printStackTrace();
            }
        }
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/sharedconfig/SharedConfig.java <==
package cloud.yogurt.shared.sharedconfig;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

public class SharedConfig {
    public static String CURRENT_API_VERSION = "YC1";
    public static Charset HEADER_CHARSET = StandardCharsets.UTF_16;
    public static Charset CONTENT_CHARSET = StandardCharsets.US_ASCII;

    public static InetAddress SERVER_ADDRESS;
    public static int SERVER_PORT = 3000;
    public static int MAX_DATAGRAM = 100;  // byte, default 65507
    public static int PACKET_HEADER_SIZE = 4 * 3;
    public static int MAX_PACKET_PAYLOAD = MAX_DATAGRAM - PACKET_HEADER_SIZE;

    public static String CLIENT_BASE_PATH = System.getProperty("user.home") + "/YogurtCloud";
    public static String SERVER_BASE_PATH = System.getProperty("user.home") + "/YogurtServer";

    public static long RESENT_TIMEOUT = 200;
    public static int MAXIMUM_RETRY = 100;

    static {
        try {
            SERVER_ADDRESS = InetAddress.getByName("127.0.0.1");
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}

==> ./shared/src/main/java/cloud/yogurt/shared/time/SetTimeout.java <==
package cloud.yogurt.shared.time;

/**
 * Helper class to execute a handler after a duration of time.
 */
public class SetTimeout extends Thread {

    private long duration;
    private TimeoutHandler timeoutHandler;

    public SetTimeout(TimeoutHandler timeoutHandler, long duration) {
        this.timeoutHandler = timeoutHandler;
        this.duration = duration;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(duration);
            this.timeoutHandler.handleTimeout();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void setTimeout(TimeoutHandler timeoutHandler, long duration) {
        new SetTimeout(timeoutHandler, duration).start();
    }

}

==> ./shared/src/main/java/cloud/yogurt/shared/time/TimeoutHandler.java <==
package cloud.yogurt.shared.time;

/**
 * Interface to handler to handle something to be executed after a timeout.
 */
public interface TimeoutHandler {
    void handleTimeout();
}

==> ./shared/src/test/java/cloud/yogurt/shared/header/HeaderTest.java <==
package cloud.yogurt.shared.header;

import org.junit.After;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.*;

public class HeaderTest {
    Header header;

    @After
    public void prepareHeader() {
        String string = header.toString();
        Header after = Header.fromString(string);
        System.out.println("HEADER\n" + string + "========");
        assertEquals(string, after.toString());
    }

    @Test
    public void test1() {
        String params[] = {"GET", "test.txt"};
        List<HeaderRow> rows = new ArrayList<>();
        header = new Header(params, rows);
    }

    @Test
    public void test2() {
        String params[] = {"NOTICE"};
        List<HeaderRow> rows = new ArrayList<>();
        rows.add(new HeaderRow("abc", new HeaderStringValue("def")));
        rows.add(new HeaderRow("abc", new HeaderIntegerValue(123)));
        header = new Header(params, rows);
    }
}

==> ./shared/src/test/java/cloud/yogurt/shared/message/HeaderDataLoaderTest.java <==
package cloud.yogurt.shared.message;

import cloud.yogurt.shared.header.Header;
import org.junit.Test;

import java.io.IOException;
import java.util.ArrayList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class HeaderDataLoaderTest {
    @Test
    public void test1() throws IOException {
        HeaderDataLoader loader = new HeaderDataLoader(
                new Header(new String[]{"GET", "test.txt"}, new ArrayList<>())
        );

        byte[] buffer = new byte[1000];
        int read = loader.read(buffer);
        assertEquals(read, 36);
    }
}

==> ./shared/src/test/java/cloud/yogurt/shared/network/EndPointCallTest.java <==
package cloud.yogurt.shared.network;

import org.junit.Test;

import java.net.InetAddress;
import java.net.UnknownHostException;

import static org.junit.Assert.assertEquals;

public class EndPointCallTest {
    @Test
    public void test() throws UnknownHostException {
        EndPoint epA = new EndPoint();
        epA.address = InetAddress.getByName("127.0.0.1");
        epA.port = 12;
        EndPointCall cA = new EndPointCall(epA, 4);
        EndPoint epB = new EndPoint();
        epB.address = InetAddress.getByName("127.0.0.1");
        epB.port = 12;
        EndPointCall cB = new EndPointCall(epB, 4);
        assertEquals(cA, cB);
    }
}

==> ./shared/src/test/java/cloud/yogurt/shared/network/PacketTest.java <==
package cloud.yogurt.shared.network;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.*;

public class PacketTest {

    private Packet packet;

    @Before
    public void preparePacket() {
        System.out.println("Create empty packet for testing.");
        packet = new Packet();
    }

    @After
    public void testPacket() throws PacketException {
        Packet decodedPacket = new Packet();
        decodedPacket.decodeDatagram(packet.construct());

        System.out.println("Compare constructed packet with original one.");

        assertEquals(packet.callId, decodedPacket.callId);
        assertEquals(packet.eomFlag, decodedPacket.eomFlag);
        assertEquals(packet.resFlag, decodedPacket.resFlag);
        assertEquals(packet.ackFlag, decodedPacket.ackFlag);

        assertEquals(packet.id, decodedPacket.id);
        assertEquals(packet.ackPacket, decodedPacket.ackPacket);

        assertEquals(packet.content.length, decodedPacket.content.length);
        assertArrayEquals(packet.content, decodedPacket.content);

        System.out.println("All tests passed.\n\n");
    }

    @Test
    public void testPacketConstruct1() {
        packet.callId = 5;
        packet.eomFlag = true;
        packet.resFlag = false;
        packet.ackFlag = false;

        packet.id = 123;
        packet.ackPacket = 456;

        packet.content = new byte[]{1, 2, 3, 4, 5};
    }

    @Test
    public void testPacketConstruct2() {
        packet.callId = 7;
        packet.eomFlag = false;
        packet.resFlag = true;
        packet.ackFlag = false;

        packet.id = 1234;
        packet.ackPacket = 5678;

        packet.content = new byte[]{1, 2, 3, 4, 5, 6};
    }

    @Test
    public void testPacketConstruct3() {
        packet.callId = -1;
        packet.eomFlag = false;
        packet.resFlag = false;
        packet.ackFlag = true;

        packet.id = 0;
        packet.ackPacket = 1;

        packet.content = new byte[]{1, 2, 3, 4, 5, 7};
    }
}
